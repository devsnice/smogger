{"version":3,"sources":["../../../src/components/parser/index.js"],"names":["SPEC","getSpec","undefined","Error","parseRef","ref","slice","setSpec","spec","getMethodModel","path","method","paths","toLowerCase","resolveRef","schema","$ref","getResponse","status","contentType","responses","content","processor","cb","mutators","next","bind","properties","reduce","result","key","property","items","map","item","combiner","oneOf","anyOf","allOf"],"mappings":"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","sourcesContent":["import type { ContentType, Method, Schema } from \"../../types/Swagger\";\nimport { entries, objectPath } from \"../../utils/utils\";\nimport { allOf, anyOf, oneOf } from \"./combiners\";\n\nexport type MutatorItems = (schema: Schema) => Array<any>;\nexport type Mutators = {\n  items?: MutatorItems\n};\n\nlet SPEC = null;\n\nconst getSpec = () => {\n  if (SPEC === undefined) { throw new Error(`Spec didn't loaded (or passed to parser). Use setSpec()`); }\n  return SPEC;\n};\n\n// $FlowFixMe\nconst parseRef = (ref: string): Schema => objectPath(getSpec(), ref.slice(2), '/');\n\nexport const setSpec = (spec: Schema) => SPEC = spec;\n\nexport const getMethodModel: (path: string, method: string) => Method =\n  (path, method) =>\n    // $FlowFixMe\n    getSpec().paths[path][method.toLowerCase()];\n\nexport const resolveRef = (schema: Schema) => {\n  if (schema.$ref) { return parseRef(schema.$ref); }\n  return schema;\n};\n\nexport const getResponse: (method: Method, status?: number, contentType?: ContentType) => Schema\n  = (method, status = 200, contentType = 'application/json') => {\n  const schema = method.responses[status].content[contentType].schema;\n  return resolveRef(schema);\n};\n\nexport const processor: (cb: (data: Schema) => any, mutators: Mutators, schema: Schema) => any\n  = (cb, mutators, schema) => {\n  const next = processor.bind(this, cb, mutators);\n  if ('$ref' in schema) {\n    return next(resolveRef(schema));\n  }\n\n  if (schema.properties) {\n    return entries(schema.properties).reduce((result, [key, property]) => {\n      result[key] = next(property);\n      return result;\n    }, {});\n  }\n\n  if (schema.items) {\n    if (mutators.items) {\n      return mutators.items(schema).map(item => next(item));\n    }\n    return next(schema.items);\n  }\n\n  if ('oneOf' in schema || 'anyOf' in schema || 'allOf' in schema) {\n    let combiner = () => schema;\n    if (schema.oneOf) {combiner = oneOf(schema.oneOf)}\n    if (schema.anyOf) {combiner = anyOf(schema.anyOf)}\n    if (schema.allOf) {combiner = allOf(schema.allOf.map(parseRef))}\n\n    return next(combiner());\n  }\n\n  return cb(schema);\n};\n"],"file":"index.js"}